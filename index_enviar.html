<!DOCTYPE html>
<html lang="en">

<head>
   <meta charset="utf-8">
   <title>Desafio</title>


   <style type="text/css">
      * {
         margin: 0;
         padding: 0;
         font-family: sans-serif;
         color: #333;
      }

      .container {
         text-align: center;
         max-width: 1200px;
         margin: 0 auto;
      }

      button {
         margin: 5px;
         padding: 5px 10px;
      }

      #board {
         display: inline-block;
         margin-top: 5px;
      }

      .row {
         height: 11px;
      }

      .cell {
         border: .5px solid #ccc;
         width: 10px;
         height: 10px;
         display: inline-block;
         position: relative;
      }

      .cell.path {
         background-color: orange;
      }

      .cell.green {
         background-color: green;
      }

      .cell.start,
      .cell.end {
         background-color: yellow;
      }

      .cell.player::after {
         content: "";
         position: absolute;
         left: 1px;
         top: 1px;
         width: 8px;
         height: 8px;
         border-radius: 50%;
         background-color: blue;
      }

      .cell.player.loser::after {
         background-color: red;
      }

      #status-text {
         margin-top: 5px;
         font: sans-serif 12pt;
         font-weight: bold;
      }

      .status-winner {
         color: green;
      }

      .status-loser {
         color: red;
      }

      #move-list {
         width: 100%;
         min-width: 100%;
         min-height: 100px;
         border: 1px solid #ccc;
         margin-top: 10px;
         background-color: #f9f9f9;
      }
   </style>

</head>

<body>
   <!-- page content -->
   <div class="container">
      <button onclick="search_path_with_progress()">Search (visualize progress)</button>
      <button onclick="search_path()">Search and test</button>
      <button onclick="reset();">Reset</button>
      <br>

      <div id="board"></div>

      <div id="status">
         <p id="status-text">Game Over!</p>
      </div>

      <textarea id="move-list" readonly></textarea>

   </div>

   <script>
      // we opted to use a variation of the A* algorithm to solve the problem
      async function aStarForDynamicGrid(start, end, initialGrid, rows, cols, gridGenerationCallback,
         renderProgressCallback) {

         const stages = [];
         stages.push(initialGrid);

         // Define the node class
         class Node {
            constructor(state, parent, gScore) {
               this.state = state;
               this.parent = parent;
               this.gScore = gScore;

               // add wheigths to the heuristic to make the algorithm more efficient
               this.fScore = this.gScore + (heuristic(this) * 3);
            }
         }

         function getNextGridState(depth) {

            // test if we already have the grid state for the current depth
            if (stages.length <= depth) {
               // if not, calculate the next grid state
               let prevStage = stages[depth - 1];
               let nextStage = gridGenerationCallback(prevStage, rows, cols);
               stages.push(nextStage);
            }

            return stages[depth];
         }

         function heuristic(node) {
            let [row, col] = node.state;
            let [endRow, endCol] = end;
            let [startRow, startCol] = start;

            // Manhattan distance
            // return Math.abs(row - endRow) + Math.abs(col - endCol);

            // Cross line tie breaker to optimize the number of turns and get a more straight line (natural path)
            let dx1 = Math.abs(row - endRow);
            let dy1 = Math.abs(col - endCol);
            let dx2 = Math.abs(startRow - endRow);
            let dy2 = Math.abs(startCol - endCol);
            let cross = Math.abs(dx1 * dy2 - dx2 * dy1);
            return (dx1 + dy1) + (cross * 0.001);
         }

         function getCost(current, neighbor) {
            // allways move 1 space per turn
            return 1;
         }

         function compareArrays(a, b) {
            return a.length === b.length && a.every((v, i) => v === b[i]);
         }

         function getNeighbors(state, gridState) {
            let neighbors = [];
            let [row, col, depth] = state;

            // Check the left neighbor
            if (col > 0 && gridState[row][col - 1] !== 1) {
               neighbors.push([row, col - 1, depth + 1]);
            }

            // Check the right neighbor
            if (col < gridState[0].length - 1 && gridState[row][col + 1] !== 1) {
               neighbors.push([row, col + 1, depth + 1]);
            }

            // Check the top neighbor
            if (row > 0 && gridState[row - 1][col] !== 1) {
               neighbors.push([row - 1, col, depth + 1]);
            }

            // Check the bottom neighbor
            if (row < gridState.length - 1 && gridState[row + 1][col] !== 1) {
               neighbors.push([row + 1, col, depth + 1]);
            }

            return neighbors;
         }

         let count = 0;
         let nodeCount = 0;

         // Initialize the open and closed sets
         let openSet = [new Node([...start, 0], null, 0)];
         let closedSet = [];

         // Search for the path
         while (openSet.length > 0) {
            count++;

            // Get the current node (you can use binary heap here to fasten the search)
            let current = openSet.reduce((a, b) => (a.fScore < b.fScore) ? a : b);

            // Check if we've reached the target node
            if (current.state[0] === end[0] && current.state[1] === end[1]) {
               let path = [];
               while (current !== null) {
                  path.push(current.state);
                  current = current.parent;
               }
               console.log('count', count, 'nodeCount', nodeCount);
               return path.reverse();
            }

            // prevent long running searches
            if (count > 10000) {
               console.error('Reached max allowed iterations');
               return;
            }

            // Get the next grid state
            let gridState = getNextGridState(current.state[2] + 1);

            // Get the neighbors
            let neighbors = getNeighbors(current.state, gridState);

            // Check the neighbors
            for (let neighbor of neighbors) {
               // Calculate the tentative g score
               let tentativeGScore = current.gScore + getCost(current.state, neighbor);

               // Check if the neighbor is already in the closed set
               if (closedSet.some(node => compareArrays(node.state, neighbor))) {
                  continue;
               }

               // Check if the neighbor is already in the open set
               let openNode = openSet.find(node => compareArrays(node.state, neighbor));
               if (openNode === undefined) {
                  openSet.push(new Node(neighbor, current, tentativeGScore));
                  nodeCount++;
               } else if (tentativeGScore < openNode.gScore) {
                  openNode.gScore = tentativeGScore;
                  openNode.parent = current;
                  nodeCount++;
               }
            }

            // Move the current node to the closed set
            openSet = openSet.filter(node => !compareArrays(node.state, current.state));
            closedSet.push(current);
         }

         // No path was found
         return null;
      }

      // button click
      async function search_path() {
         reset();

         var path = await aStarForDynamicGrid(game.start, game.end, game.stage, game.rows, game.cols, Game
            .calculateNextPopulation);

         if (path == null) {
            alert("No path found");
            return;
         }

         let game_path = [];
         let directions = [];
         let last = game.start;

         // convert path to directions UP, DOWN, LEFT, RIGHT
         path.forEach((current) => {
            let [fromRow, fromCol] = last;
            let [toRow, toCol] = current;

            if (toRow > fromRow) {
               directions.push("D");
            } else if (toRow < fromRow) {
               directions.push("U");
            } else if (toCol > fromCol) {
               directions.push("R");
            } else if (toCol < fromCol) {
               directions.push("L");
            }

            last = current;
         });

         // convert directions to game path
         document.getElementById('move-list').innerHTML = directions.join(' ');
      }

      function search_path_with_progress() {

      }

      // helper function to compare two one-dimensional arrays
      function compareArrays(a, b) {
         return a.length === b.length && a.every((v, i) => v === b[i]);
      }

      const GameStatus = {
         PLAYING: "playing",
         SEARCHING: "searching",
         WIN: "win",
         LOSE: "lose",
         PAUSE: "pause",
      }

      class Game {
         constructor(rows, cols) {
            this.status = GameStatus.PAUSE;

            this.cols = cols;
            this.rows = rows;
            this.stage = [];

            this.start = null;
            this.end = null;
            this.player = null;

            // used to draw progress
            this.path = [];
            this.openSet = [];
            this.closedSet = [];
         }

         loadDataFromString(str) {
            this.stage = [];
            for (let i = 0; i < this.rows; i++) {
               this.stage[i] = [];
               for (let j = 0; j < this.cols; j++) {
                  let idx = i * this.cols + j;
                  this.stage[i][j] = parseInt(str.length > idx ? str[idx] : 0);

                  // set the starting point
                  if (this.stage[i][j] === 3) {
                     this.start = [i, j];
                     this.player = [i, j];
                  }

                  // set the goal
                  if (this.stage[i][j] === 4) {
                     this.end = [i, j];
                  }

               }
            }
         }

         updatePopulation() {
            this.stage = Game.calculateNextPopulation(this.stage, this.rows, this.cols);
         }

         static calculateNextPopulation(data, rows, cols) {
            let next = [];

            for (let i = 0; i < rows; i++) {
               next.push([]);
               for (let j = 0; j < cols; j++) {
                  let greenNeighbors = 0;

                  greenNeighbors += (i > 0 && j > 0) ? data[i - 1][j - 1] == 1 : 0;
                  greenNeighbors += (i > 0) ? data[i - 1][j] == 1 : 0;
                  greenNeighbors += (i > 0 && j < cols - 1) ? data[i - 1][j + 1] == 1 : 0;
                  greenNeighbors += (j > 0) ? data[i][j - 1] == 1 : 0;
                  greenNeighbors += (j < cols - 1) ? data[i][j + 1] == 1 : 0;
                  greenNeighbors += (i < rows - 1 && j > 0) ? data[i + 1][j - 1] == 1 : 0;
                  greenNeighbors += (i < rows - 1) ? data[i + 1][j] == 1 : 0;
                  greenNeighbors += (i < rows - 1 && j < cols - 1) ? data[i + 1][j + 1] == 1 : 0;

                  next[i].push(data[i][j]);

                  // White cells turn green if they have a number of adjacent green cells greater than 1 and less than 5. Otherwise, they remain white.
                  if (data[i][j] === 0) {
                     next[i][j] = ((greenNeighbors > 1 && greenNeighbors < 5) ? 1 : 0);
                  }

                  // Green cells remain green if they have a number of green adjacent cells greater than 3 and less than 6. Otherwise they become white.
                  if (data[i][j] === 1) {
                     next[i][j] = ((greenNeighbors > 3 && greenNeighbors < 6) ? 1 : 0);
                  }

                  // No rules for yellow cells (start and end)
               }

            }

            return next;
         }

         move(direction) {
            if (this.status !== GameStatus.PLAYING) {
               return;
            }

            if (!this.isValidMove(direction)) {
               this.status = GameStatus.LOSE;
               this.render();
               return;
            }

            if (direction === "U") {
               this.player[0]--;
            } else if (direction === "D") {
               this.player[0]++;
            } else if (direction === "L") {
               this.player[1]--;
            } else if (direction === "R") {
               this.player[1]++;
            }

            // keep track of the path
            this.path.push([this.player[0], this.player[1]]);

            this.updatePopulation();
            this.testLoseCondition();
            this.testWinCondition();
            this.render();
         }

         isValidMove(direction) {

            // out of bounds moves
            if (direction === "U" && this.player[0] === 0) {
               return false;
            }

            if (direction === "D" && this.player[0] === this.rows - 1) {
               return false;
            }

            if (direction === "L" && this.player[1] === 0) {
               return false;
            }

            if (direction === "R" && this.player[1] === this.cols - 1) {
               return false;
            }

            return true;
         }

         testLoseCondition() {
            if (this.status !== GameStatus.PLAYING) {
               return;
            }

            // hit a live cell
            if (this.stage[this.player[0]][this.player[1]] === 1) {
               this.status = GameStatus.LOSE;
            }

         }

         testWinCondition() {
            if (this.status !== GameStatus.PLAYING) {
               return;
            }

            // reached the goal
            if (this.player[0] === this.end[0] && this.player[1] === this.end[1]) {
               this.status = GameStatus.WIN;
            }
         }

         render() {

            let statusElement = document.getElementById("status");
            statusElement.classList.remove("status-winner");
            statusElement.classList.remove("status-loser");
            statusElement.innerHTML = "";

            // Render status
            if (this.status === GameStatus.PLAYING) {
               statusElement.innerHTML = "Playing...";
            }

            if (this.status === GameStatus.SEARCHING) {
               statusElement.innerHTML = "Searching...";
            }

            if (this.status === GameStatus.WIN) {
               statusElement.innerHTML = "You Win!";
               statusElement.classList.add("status-winner");
            }

            if (this.status === GameStatus.LOSE) {
               statusElement.innerHTML = "You Lose!";
               statusElement.classList.add("status-loser");
            }

            // Render the game board
            let board = document.getElementById("board");

            board.innerHTML = "";

            for (let i = 0; i < this.rows; i++) {
               let row = document.createElement("div");
               row.classList.add("row");
               board.appendChild(row);

               for (let j = 0; j < this.cols; j++) {
                  let cell = document.createElement("div");
                  cell.classList.add("cell");
                  row.appendChild(cell);

                  if (this.stage[i][j] === 1) {
                     cell.classList.add("green");
                  }

                  if (i === this.start[0] && j === this.start[1]) {
                     cell.classList.add("start");
                  }

                  if (i === this.end[0] && j === this.end[1]) {
                     cell.classList.add("end");
                  }

                  if (this.path.find((x) => x[0] === i && x[1] === j)) {
                     cell.classList.add("path");
                  }

                  if (i === this.player[0] && j === this.player[1]) {
                     cell.classList.add("player");

                     if (this.status === GameStatus.LOSE) {
                        cell.classList.add("loser");
                     } else {
                        cell.classList.remove("loser");
                     }
                  }
               }
            }
         }

      }

      let game;
      let interval;
      let delay = 100;
      let isFollowingPath = false;
      let pathToFollow = [];

      // path finder
      let previousNode = null;
      let attemptedMoves = {};

      function reset() {
         game = new Game(65, 85);

         let initialData = "3000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111110000000000000000000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111000000000000000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111110000000000000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111100000000000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111000000000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111110000000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111111000000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111111110000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111111111000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111111111100000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111111111110000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111111111110000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111111111111000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111111111111100000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111111111111110000000000000000";
         initialData += "0000000000000000000000000100000000000000000001111111111111111111111110000000000000000";
         initialData += "0000000000000000000000001110000000000000000000001111111111111111111111000000000000000";
         initialData += "0000000000000000000000011110000000000000000000000011111111111111111111000000000000000";
         initialData += "0000000000000000000000111110000000000000000000000000111111111111111111100000000000000";
         initialData += "0000000000000000000001111110000000000000000000000000011111111111111111100000000000000";
         initialData += "0000000000000000000011111110000000000000000000000000001111111111111111100000000000000";
         initialData += "0000000000000000000111111110000000000000000000000000000111111111111111110000000000000";
         initialData += "0000000000000000001111111110000000000000000000000000000111111111111111110000000000000";
         initialData += "0000000000000000011111111110000000000000000000000000000011111111111111110000000000000";
         initialData += "0000000000000000111111111110000000000000000000000000000011111111111111110000000000000";
         initialData += "0000000000000001111111111110000000000000000000000000000001111111111111111000000000000";
         initialData += "0000000000000011111111111110000000000000000000000000000001111111111111111000000000000";
         initialData += "0000000000000111111111111110000000000000000000000000000001111111111111111000000000000";
         initialData += "0000000000001111111111111110000000000000000000000000000000111111111111111000000000000";
         initialData += "0000000000001111111111111110000000000000000000000000000000111111111111111000000000000";
         initialData += "0000000000001111111111111110000000000000000000000000000000111111111111111000000000000";
         initialData += "0000000000001111111111111110000000000000000000000000000000111111111111111000000000000";
         initialData += "0000000000001111111111111110000000000000000000000000000000111111111111111000000000000";
         initialData += "0000000000000111111111111110000000000000000000000000000001111111111111111000000000000";
         initialData += "0000000000000011111111111110000000000000000000000000000001111111111111111000000000000";
         initialData += "0000000000000001111111111110000000000000000000000000000001111111111111111000000000000";
         initialData += "0000000000000000111111111110000000000000000000000000000011111111111111110000000000000";
         initialData += "0000000000000000011111111110000000000000000000000000000011111111111111110000000000000";
         initialData += "0000000000000000001111111110000000000000000000000000000111111111111111110000000000000";
         initialData += "0000000000000000000111111110000000000000000000000000000111111111111111110000000000000";
         initialData += "0000000000000000000011111110000000000000000000000000001111111111111111100000000000000";
         initialData += "0000000000000000000001111110000000000000000000000000011111111111111111100000000000000";
         initialData += "0000000000000000000000111110000000000000000000000000111111111111111111100000000000000";
         initialData += "0000000000000000000000011110000000000000000000000011111111111111111111000000000000000";
         initialData += "0000000000000000000000001110000000000000000000001111111111111111111111000000000000000";
         initialData += "0000000000000000000000000100000000000000000001111111111111111111111110000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111111111111110000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111111111111100000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111111111111000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111111111110000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111111111110000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111111111100000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111111111000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111111110000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111111000000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111110000000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111111000000000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111111100000000000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111110000000000000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111111111000000000000000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000111110000000000000000000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
         initialData += "0000000000000000000000000000000000000000000000000000000000000000000000000000000000004";

         game.loadDataFromString(initialData);
         game.render();
      }

      reset();
   </script>
</body>

</html>